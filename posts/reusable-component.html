<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/fire.jpeg"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/fire.jpeg"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/fire.jpeg"/><link rel="manifest" href="/favicon/fire.jpeg"/><link rel="mask-icon" href="/favicon/fire.jpeg" color="#000000"/><link rel="shortcut icon" href="/favicon/fire.jpeg"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/favicon/fire.jpeg"/><meta name="description" content="codeKiuk"/><title>재사용 가능한 컴포넌트 만들기 | Error</title><meta property="og:image" content="/assets/blog/reusable-component/preview.png"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/02cef8d60abc4ccd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/02cef8d60abc4ccd.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e1f6961df2961232.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1f6961df2961232.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-38102973b285480e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20835bb07712f6c7.js" defer=""></script><script src="/_next/static/chunks/202-c144248cd2d53e87.js" defer=""></script><script src="/_next/static/chunks/72-32489d1a2b163d71.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-336c2ced50a7659a.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_buildManifest.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_ssgManifest.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-xl md:text-2xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" style="color:black" href="/">Kiuk</a>.</h2><article class="mb-32"><h1 class="text-3xl md:text-4xl lg:text-5xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">재사용 가능한 컴포넌트 만들기</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><img src="/assets/blog/authors/FIRE.jpeg" class="w-12 h-12 rounded-full mr-4"/><div class="text-xl font-bold"><a style="color:black">codeKiuk</a></div></div></div><div class="mb-8 md:mb-16 sm:mx-0"><div class="sm:mx-0"><img src="/assets/blog/reusable-component/preview.png" alt="Cover Image for 재사용 가능한 컴포넌트 만들기" class="shadow-sm"/></div></div><div class="max-w-2xl mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><img src="/assets/blog/authors/FIRE.jpeg" class="w-12 h-12 rounded-full mr-4"/><div class="text-xl font-bold"><a style="color:black">codeKiuk</a></div></div></div><div class="mb-6 text-lg"><time dateTime="2021-09-01">September	1, 2021</time></div></div><div class="max-w-3xl mx-auto"><div class="markdown-styles_markdown__h_8de"><h3>들어가며</h3>
<p>풀스택 CRUD 게시판을 하나 만들어보자 라는 생각으로 21.08.15에 시작한 동아리 | 소모임 게시판 서비스 Ginger의 <a href="https://github.com/codeKiuk/Ginger">코드</a> 를 천천히 뜯어보며 리팩토링 하기로 마음먹었다.</p>
<p>내가 쓴 코드가 일단 돌아만 가는 <s>개노답</s> 코드라는 걸 알고는 있었지만 뭘 어떻게 만들어야 확장성이 좋은 코드인지, 어떻게 짜는 것이 클-린한지 몰랐다.</p>
<p>그러다가 <a href="https://jbee.io/etc/what-is-good-code/">이 글</a> 을 보고 조금의 힌트를 얻어, 선배님이 생각하시는 좋은 코드의 기준인</p>
<ul>
<li>
<p>의존성이 잘 드러나도록 추상화되어 있는가</p>
</li>
<li>
<p>확장성 있는 컴포넌트인가</p>
</li>
</ul>
<p>에 맞춰 리팩토링을 진행하기로 했다.</p>
<h3>프로젝트 구조 파악</h3>
<p>의존성을 잘 드러내는 추상화 (한 파일이 하나의 목적을 갖도록 로직 분리) 를 이루기 위해서는</p>
<p>우선 프로젝트의 구조를 파악해 어떤 로직들이 존재하고,</p>
<p>이 로직들이 어느 파일에 어떻게 존재하는지 파악하는 것이 먼저다.</p>
<img src="/assets/blog/reusable-component/directory0.png" width="200" height="500">
<p>redux 구조</p>
<img src="/assets/blog/reusable-component/directory1.png" width="200" height="500">
<p>컴포넌트들</p>
<img src="/assets/blog/reusable-component/directory2.png" width="200" height="500">
<img src="/assets/blog/reusable-component/directory3.png" width="200" height="500">
<p>Route &#x26; Higher Order Components</p>
<p>Ginger 클라이언트 디렉토리는 어떤 기능을 하는지 (component인지, route page인지, redux인지) 에 따라 폴더 구조를 나눴다.</p>
<ol>
<li>이 구조가 가질 수 있는 문제점은 플젝 규모가 커지면 코드가 정의된 곳과 이를 사용하는 곳이 멀어질 수 있다는 점.. <s>사실 이미 좀 멀어져 있다...</s></li>
<li>또한 MVC라든지 MVVM라든지 디자인 패턴에 대한 지식 없이 구성해서 좋은 의존성에 대한 고민을 많이 못 했다. ⇒ ( components/commons/Pagination.tsx 이라는 컴포넌트 안에 pagination view 로직이 들어있는 동시에 컨텐츠를 가져오는 상태 관련 로직이 동시에 존재하는 등 의존성 분리를 하지 못 했다. )</li>
</ol>
<h3>문제 찾아보기</h3>
<p>먼저 프로젝트 코드 전반적으로 redux와 thunk를 통해 전역 상태와 data fetch를 다루면서 재사용 가능한 컴포넌트를 많이 만들지 못 했다. (redux 덕분에 자식 컴포넌트에 props를 내려주는 일을 거의 안 하면서..)</p>
<p>그럼에도 불구하고 확장성을 생각한 포인트로는</p>
<p>→ withPaperContainer라는 고차컴포넌트를 통해 동아리 게시판 전체 글을 불러오거나 내가 쓴 글, 댓글을 불러오는 등 컨텐츠를 fetch하는 <strong>중복되는 로직</strong>을 한 곳에서 처리했다.</p>
<p>그렇다면 이 외에 재사용 가능하도록 만들어볼 <s>구린</s> 컴포넌트 혹은 view로직과 상태 로직이 같이 있는 복잡한 컴포넌트를 찾아보자.</p>
<blockquote>
<p>Sidebar</p>
</blockquote>
<p>Sidebar에서 메뉴를 클릭하면 클릭한 메뉴가 어떤 메뉴인지 전역 store에 ContentSubject라는 enum 타입을 통해 저장한다. 이후 해당하는 컨텐츠(글or댓글 등)를 불러오는 함수를 dispatch한다.</p>
<p>그런데 Sidebar에서 메뉴 클릭 후 라우트를 mypage 혹은 home으로 옮겨오는데, 이 때 각 라우트를 구성하는 컴포넌트의 useEffect에서도 Sidebar에서와 마찬가지로 컨텐츠를 불러오는 함수를 dispatch한다.</p>
<p>따라서 개발 당시 만들었던 중복 로직을 삭제해줬다.</p>
<pre><code>// 수정된 Sidebar.tsx
// 클릭한 메뉴에 따라 전역 store에 알려주는 함수에서 중복 로직 삭제

const onClickContentsMenu = (title: string) => {
    switch (title) {
        case '동아리 / 학회':
            dispatch(setContentSubject(ContentSubject.CLUB_CONTENT))
            // 중복로직 삭제 => dispatch(getClubContents({ page: 1, perPage: perPage }));
            break
        case '스터디 / 소모임':
            dispatch(setContentSubject(ContentSubject.GROUP_CONTENT))
            // 중복로직 삭제 => dispatch(getGroupContents({ page: 1, perPage: perPage }));
            break
        case '내가 쓴 글':
            dispatch(setContentSubject(ContentSubject.MY_CONTENT))
            // 중복로직 삭제 => dispatch(getMyContents({ userID: userID ,page: 1, perPage: perPage }));
            break
        case '내가 쓴 댓글':
            dispatch(setContentSubject(ContentSubject.MY_COMMENT))
            // 중복로직 삭제 => dispatch(getMyComments({ userID: userID ,page: 1, perPage: perPage }));
            break
        default:
            break
    }
}
</code></pre>
<blockquote>
<p>Pagination</p>
</blockquote>
<p>글을 쓰게 된 계기인 <s>개구린</s> 페이지네이션 컴포넌트.</p>
<p>먼저 바뀌기 전 코드를 보자.</p>
<pre><code>// Pagination.tsx

export const Pagination: React.FC&#x3C;{}> = () => {
    const contentsLoading = useAppSelector((state) => state.contents.loading)
    const myCommentsLoading = useAppSelector(
        (state) => state.myComments.loading
    )
    const myContentsLoading = useAppSelector(
        (state) => state.myContents.loading
    )

    const loading = contentsLoading || myCommentsLoading || myContentsLoading
    const contentSubject = useAppSelector(
        (state) => state.contentMenu.contentSubject
    )

    // ...

    const onPageClick = (pageNum: number) => {
        switch (contentSubject) {
            case ContentSubject.CLUB_CONTENT:
                dispatch(getClubContents({ page: pageNum, perPage: perPage }))
                break
            case ContentSubject.GROUP_CONTENT:
                dispatch(getGroupContents({ page: pageNum, perPage: perPage }))
                break
            case ContentSubject.MY_CONTENT:
                dispatch(
                    getMyContents({
                        userID: userID,
                        page: pageNum,
                        perPage: perPage,
                    })
                )
                break
            case ContentSubject.MY_COMMENT:
                dispatch(
                    getMyComments({
                        userID: userID,
                        page: pageNum,
                        perPage: perPage,
                    })
                )
                break
            default:
                break
        }

        setPage(pageNum)
    }

    // ...
}
</code></pre>
<p>대충 봐도 재사용하기 어려운 컴포넌트라는 것을 알 수 있다.</p>
<p>-문제-</p>
<ol>
<li>
<p>사이드바 메뉴 (즉 게시판 종류) 가 늘어났을 때 switch문 안에 case를 추가할 수 있겠으나 가독성이 떨어진다.</p>
</li>
<li>
<p>또한 Pagination만 하는 컴포넌트인데 컨텐츠를 가져오는 로직이 섞여있어서 유지보수하기 어려워보인다.</p>
<p>이는 Sidebar에서도 있었던 문제로, 컨텐츠를 가져오는 로직이 여러 군데 퍼져있다.</p>
</li>
<li>
<p>loading 또한 게시판 메뉴가 확장될 때마다 하드코딩해야한다.</p>
</li>
</ol>
<p>따라서 Pagination 컴포넌트의 부모 컴포넌트 역할을 하는 withPaperContainer의 코드를 수정함으로 위 문제를 해결했다.</p>
<ol>
<li>Page를 옮겼을 때 새로 컨텐츠를 가져와야 하는 것은 꼭 필요한 로직이기 때문에 Pagination의 부모 컴포넌트에서 prop으로 getPapers 함수를 넘겨준다. (뒤에서 컨텐츠를 가져오는 상태 로직을 커스텀 훅으로 분리할 예정이다.)</li>
<li>로딩 또한 페이지네이션 컴포넌트가 아닌 부모 컴포넌트에서 처리해준다.</li>
</ol>
<pre><code>// withPaperContainer.tsx

**let getPapers = Function();**

// ...

const renderPapers = () => {

            switch (contentSubject) {

                case ContentSubject.CLUB_CONTENT:
                    dispatch(setTotalDocs(contentsCount));
                    **getPapers = getClubContents;**
                    return renderContents(clubContents);

								case ContentSubject.GROUP_CONTENT:
                    dispatch(setTotalDocs(contentsCount));
                    **getPapers = getGroupContents;**
                    return renderContents(groupContents);
										// ...
// ...

return (
            &#x3C;>
                &#x3C;div>
                    {loading &#x26;&#x26; &#x3C;Loading />}
                    {!loading &#x26;&#x26; renderPapers()}
                &#x3C;/div>
                &#x3C;br />
                {!loading &#x26;&#x26; &#x3C;Pagination **getPapers={getPapers}** />}
            &#x3C;/>
        )
</code></pre>
<p>prop으로 받은 getPapers 함수를 통해 switch문을 삭제했다.</p>
<p>한결 깔끔해진 것 같다.</p>
<pre><code>// Pagination.tsx

const onPageClick = (pageNum: number) => {
    dispatch(getPapers({ userID: userID, page: pageNum, perPage: perPage }))
    setPage(pageNum)
}
</code></pre>
<p><strong>그런데 위에서 살펴봤듯이 view 로직과 data fetch 로직이 같이 있는 것이 비효율적이라는 생각을 했다.</strong></p>
<p>그래서 data fetch 로직을 수행하는 custom hook을 만들어서 컴포넌트들이 view 로직만 처리하도록 만들어보자.</p>
<h3>Custom Hook으로 의존성 분리하기</h3>
<p>그렇다면 view단 컴포넌트들이 사용하는 상태 관련 로직들이 뭐가 있는지 찾아보자.</p>
<ol>
<li>로딩 상태 (현재 fetch 중이어서 로딩 상태인지)</li>
<li>선택한 글에 따라 해당 글 상세 정보 가져오기 (댓글, 해당 글 내용, 글 작성자 등)</li>
<li>현재 어느 게시판인지에 따라 data fetch</li>
<li>pagination 용 정보 (현재 page, total pages)</li>
</ol>
<p>글이 길어져, 4에 해당하는 로직을 custom hook으로 추출해서 어떻게 의존성을 분리했는지만 살펴보자.</p>
<p>리팩토링 이전에는 위에서 살펴봤듯이 Pagination 컴포넌트에는 pagination view를 렌더링하는 로직과 더불어 페이지 클릭 시 (혹은 next, before 버튼 클릭 시) 해당 페이지에 맞는 게시글들을 불러오는 상태 로직이 같이 존재했었다.</p>
<p>따라서 view 로직만 남겨두어 가독성을 올려보자.</p>
<ol>
<li>pagination view를 위한 상태 (전체 페이지 수, 현재 페이지, 한 페이지 당 몇 row 등) 를 usePagination라는 커스텀 훅에서 다룬다.</li>
<li>게시글 fetch관련 상태 로직을 useFetchPage 라는 커스텀 훅에서 다룬다.</li>
</ol>
<p>이렇게 하면 Pagination 컴포넌트에서 상태 로직을 다루지 않고 위 두 custom hook을 구독함으로써 페이지네이션 기능을 구현할 수 있다.</p>
<p>간략한 코드를 보자.</p>
<pre><code>// usePagination.ts
export const usePagination = () => {
    **const { getPapers } = useFetchPage();**

    const [page, setPage] = useState(1);
    const [perPage, setPerPage] = useState(10);
    const totalPages = Math.ceil(totalDocs / perPage);
    const [pageList, setPageList] = useState(Array(0));

    useEffect(() => {

        settingPageList(totalPages);

    }, [page])

    const onPageClick = async (pageNum: number) => {
        setPage(pageNum);
        **getPapers(pageNum);**
    }

    const onBefore = () => { }

    const onNext = () => { }

    return { page, perPage, pageList, onPageClick }
}
</code></pre>
<p>useFetchPage 커스텀 훅으로부터 페이지 클릭 시 해당 페이지의 게시글을 렌더링하는 함수를 받아서 사용한다.</p>
<p>이렇게 하면 상태 관련 로직을 모두 커스텀 훅에서 처리할 수 있다.</p>
<p>아래는 <s>이제야 좀</s> 단순해진 Pagination 컴포넌트의 모습이다.</p>
<p>renderPageList로 view 로직만 처리하고 있어 가독성이 훨씬 좋아졌다.</p>
<pre><code>const Pagination = () => {

    const loading = useBoardLoading();
    **const { page, pageList, onPageClick } = usePagination();**

    const renderPageList = () => {
        return pageList.map(pageNum => {

            if (pageNum === page) {
                return (
                    &#x3C;Button color='primary' variant="outlined" onClick={() => onPageClick(pageNum)}>
                        {pageNum}
                    &#x3C;/Button >
                )
            } else {
                return (
                    &#x3C;Button onClick={() => onPageClick(pageNum)}>
                        {pageNum}
                    &#x3C;/Button >
                )
            }
        })
    }

    return ( ... )
}
</code></pre>
<p>위에서 withPaperContainer 라는 부모 컴포넌트를 리팩토링해서 재사용성을 높이고자 했는데, custom hook을 통해 해결하면서 부모 컴포넌트의 구조가 더 간결해졌다.</p>
<p>Pagination 컴포넌트에게 컨텐츠를 불러오는 함수를 내려줄 필요가 없어졌기 때문에 부모 컴포넌트 또한 원래 존재목적대로 렌더링 로직만 남아있게 됐다.</p>
<pre><code>// withPaperContainer.tsx

const withPaperContainer = () => {

	const PaperContainer = () => {

					.
					.
					.

		const renderPapers = () => {

            switch (contentSubject) {

                case ContentSubject.CLUB_CONTENT:
                    return renderContents(clubContents);

                case ContentSubject.GROUP_CONTENT:
                    return renderContents(groupContents);

                case ContentSubject.MY_CONTENT:
                    return renderContents(myContents);

                case ContentSubject.MY_COMMENT:
                    return renderMyComments(myComments);

                default:
                    break;
            }
    }

		return ( ... )
	}

	return PaperContainer;
}

</code></pre>
<h3>리팩토링 이후</h3>
<img src="/assets/blog/reusable-component/performance-before.png" width="500" height="300">
<img src="/assets/blog/reusable-component/performance-after.png" width="500" height="300">
<p>성능 개선을 목표로 리팩토링을 시작한 것은 아니었으나.. 성능 개선에 도움이 된 것 같다.</p>
<p>다음 글은 사이트 성능 개선을 위한 리팩토링을 해보고 써보자,,,</p></div></div></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"재사용 가능한 컴포넌트 만들기","date":"2021-09-01","slug":"reusable-component","content":"\u003ch3\u003e들어가며\u003c/h3\u003e\n\u003cp\u003e풀스택 CRUD 게시판을 하나 만들어보자 라는 생각으로 21.08.15에 시작한 동아리 | 소모임 게시판 서비스 Ginger의 \u003ca href=\"https://github.com/codeKiuk/Ginger\"\u003e코드\u003c/a\u003e 를 천천히 뜯어보며 리팩토링 하기로 마음먹었다.\u003c/p\u003e\n\u003cp\u003e내가 쓴 코드가 일단 돌아만 가는 \u003cs\u003e개노답\u003c/s\u003e 코드라는 걸 알고는 있었지만 뭘 어떻게 만들어야 확장성이 좋은 코드인지, 어떻게 짜는 것이 클-린한지 몰랐다.\u003c/p\u003e\n\u003cp\u003e그러다가 \u003ca href=\"https://jbee.io/etc/what-is-good-code/\"\u003e이 글\u003c/a\u003e 을 보고 조금의 힌트를 얻어, 선배님이 생각하시는 좋은 코드의 기준인\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e의존성이 잘 드러나도록 추상화되어 있는가\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e확장성 있는 컴포넌트인가\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e에 맞춰 리팩토링을 진행하기로 했다.\u003c/p\u003e\n\u003ch3\u003e프로젝트 구조 파악\u003c/h3\u003e\n\u003cp\u003e의존성을 잘 드러내는 추상화 (한 파일이 하나의 목적을 갖도록 로직 분리) 를 이루기 위해서는\u003c/p\u003e\n\u003cp\u003e우선 프로젝트의 구조를 파악해 어떤 로직들이 존재하고,\u003c/p\u003e\n\u003cp\u003e이 로직들이 어느 파일에 어떻게 존재하는지 파악하는 것이 먼저다.\u003c/p\u003e\n\u003cimg src=\"/assets/blog/reusable-component/directory0.png\" width=\"200\" height=\"500\"\u003e\n\u003cp\u003eredux 구조\u003c/p\u003e\n\u003cimg src=\"/assets/blog/reusable-component/directory1.png\" width=\"200\" height=\"500\"\u003e\n\u003cp\u003e컴포넌트들\u003c/p\u003e\n\u003cimg src=\"/assets/blog/reusable-component/directory2.png\" width=\"200\" height=\"500\"\u003e\n\u003cimg src=\"/assets/blog/reusable-component/directory3.png\" width=\"200\" height=\"500\"\u003e\n\u003cp\u003eRoute \u0026#x26; Higher Order Components\u003c/p\u003e\n\u003cp\u003eGinger 클라이언트 디렉토리는 어떤 기능을 하는지 (component인지, route page인지, redux인지) 에 따라 폴더 구조를 나눴다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이 구조가 가질 수 있는 문제점은 플젝 규모가 커지면 코드가 정의된 곳과 이를 사용하는 곳이 멀어질 수 있다는 점.. \u003cs\u003e사실 이미 좀 멀어져 있다...\u003c/s\u003e\u003c/li\u003e\n\u003cli\u003e또한 MVC라든지 MVVM라든지 디자인 패턴에 대한 지식 없이 구성해서 좋은 의존성에 대한 고민을 많이 못 했다. ⇒ ( components/commons/Pagination.tsx 이라는 컴포넌트 안에 pagination view 로직이 들어있는 동시에 컨텐츠를 가져오는 상태 관련 로직이 동시에 존재하는 등 의존성 분리를 하지 못 했다. )\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e문제 찾아보기\u003c/h3\u003e\n\u003cp\u003e먼저 프로젝트 코드 전반적으로 redux와 thunk를 통해 전역 상태와 data fetch를 다루면서 재사용 가능한 컴포넌트를 많이 만들지 못 했다. (redux 덕분에 자식 컴포넌트에 props를 내려주는 일을 거의 안 하면서..)\u003c/p\u003e\n\u003cp\u003e그럼에도 불구하고 확장성을 생각한 포인트로는\u003c/p\u003e\n\u003cp\u003e→ withPaperContainer라는 고차컴포넌트를 통해 동아리 게시판 전체 글을 불러오거나 내가 쓴 글, 댓글을 불러오는 등 컨텐츠를 fetch하는 \u003cstrong\u003e중복되는 로직\u003c/strong\u003e을 한 곳에서 처리했다.\u003c/p\u003e\n\u003cp\u003e그렇다면 이 외에 재사용 가능하도록 만들어볼 \u003cs\u003e구린\u003c/s\u003e 컴포넌트 혹은 view로직과 상태 로직이 같이 있는 복잡한 컴포넌트를 찾아보자.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSidebar\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSidebar에서 메뉴를 클릭하면 클릭한 메뉴가 어떤 메뉴인지 전역 store에 ContentSubject라는 enum 타입을 통해 저장한다. 이후 해당하는 컨텐츠(글or댓글 등)를 불러오는 함수를 dispatch한다.\u003c/p\u003e\n\u003cp\u003e그런데 Sidebar에서 메뉴 클릭 후 라우트를 mypage 혹은 home으로 옮겨오는데, 이 때 각 라우트를 구성하는 컴포넌트의 useEffect에서도 Sidebar에서와 마찬가지로 컨텐츠를 불러오는 함수를 dispatch한다.\u003c/p\u003e\n\u003cp\u003e따라서 개발 당시 만들었던 중복 로직을 삭제해줬다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 수정된 Sidebar.tsx\n// 클릭한 메뉴에 따라 전역 store에 알려주는 함수에서 중복 로직 삭제\n\nconst onClickContentsMenu = (title: string) =\u003e {\n    switch (title) {\n        case '동아리 / 학회':\n            dispatch(setContentSubject(ContentSubject.CLUB_CONTENT))\n            // 중복로직 삭제 =\u003e dispatch(getClubContents({ page: 1, perPage: perPage }));\n            break\n        case '스터디 / 소모임':\n            dispatch(setContentSubject(ContentSubject.GROUP_CONTENT))\n            // 중복로직 삭제 =\u003e dispatch(getGroupContents({ page: 1, perPage: perPage }));\n            break\n        case '내가 쓴 글':\n            dispatch(setContentSubject(ContentSubject.MY_CONTENT))\n            // 중복로직 삭제 =\u003e dispatch(getMyContents({ userID: userID ,page: 1, perPage: perPage }));\n            break\n        case '내가 쓴 댓글':\n            dispatch(setContentSubject(ContentSubject.MY_COMMENT))\n            // 중복로직 삭제 =\u003e dispatch(getMyComments({ userID: userID ,page: 1, perPage: perPage }));\n            break\n        default:\n            break\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePagination\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e글을 쓰게 된 계기인 \u003cs\u003e개구린\u003c/s\u003e 페이지네이션 컴포넌트.\u003c/p\u003e\n\u003cp\u003e먼저 바뀌기 전 코드를 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Pagination.tsx\n\nexport const Pagination: React.FC\u0026#x3C;{}\u003e = () =\u003e {\n    const contentsLoading = useAppSelector((state) =\u003e state.contents.loading)\n    const myCommentsLoading = useAppSelector(\n        (state) =\u003e state.myComments.loading\n    )\n    const myContentsLoading = useAppSelector(\n        (state) =\u003e state.myContents.loading\n    )\n\n    const loading = contentsLoading || myCommentsLoading || myContentsLoading\n    const contentSubject = useAppSelector(\n        (state) =\u003e state.contentMenu.contentSubject\n    )\n\n    // ...\n\n    const onPageClick = (pageNum: number) =\u003e {\n        switch (contentSubject) {\n            case ContentSubject.CLUB_CONTENT:\n                dispatch(getClubContents({ page: pageNum, perPage: perPage }))\n                break\n            case ContentSubject.GROUP_CONTENT:\n                dispatch(getGroupContents({ page: pageNum, perPage: perPage }))\n                break\n            case ContentSubject.MY_CONTENT:\n                dispatch(\n                    getMyContents({\n                        userID: userID,\n                        page: pageNum,\n                        perPage: perPage,\n                    })\n                )\n                break\n            case ContentSubject.MY_COMMENT:\n                dispatch(\n                    getMyComments({\n                        userID: userID,\n                        page: pageNum,\n                        perPage: perPage,\n                    })\n                )\n                break\n            default:\n                break\n        }\n\n        setPage(pageNum)\n    }\n\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대충 봐도 재사용하기 어려운 컴포넌트라는 것을 알 수 있다.\u003c/p\u003e\n\u003cp\u003e-문제-\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e사이드바 메뉴 (즉 게시판 종류) 가 늘어났을 때 switch문 안에 case를 추가할 수 있겠으나 가독성이 떨어진다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e또한 Pagination만 하는 컴포넌트인데 컨텐츠를 가져오는 로직이 섞여있어서 유지보수하기 어려워보인다.\u003c/p\u003e\n\u003cp\u003e이는 Sidebar에서도 있었던 문제로, 컨텐츠를 가져오는 로직이 여러 군데 퍼져있다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eloading 또한 게시판 메뉴가 확장될 때마다 하드코딩해야한다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e따라서 Pagination 컴포넌트의 부모 컴포넌트 역할을 하는 withPaperContainer의 코드를 수정함으로 위 문제를 해결했다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePage를 옮겼을 때 새로 컨텐츠를 가져와야 하는 것은 꼭 필요한 로직이기 때문에 Pagination의 부모 컴포넌트에서 prop으로 getPapers 함수를 넘겨준다. (뒤에서 컨텐츠를 가져오는 상태 로직을 커스텀 훅으로 분리할 예정이다.)\u003c/li\u003e\n\u003cli\u003e로딩 또한 페이지네이션 컴포넌트가 아닌 부모 컴포넌트에서 처리해준다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e// withPaperContainer.tsx\n\n**let getPapers = Function();**\n\n// ...\n\nconst renderPapers = () =\u003e {\n\n            switch (contentSubject) {\n\n                case ContentSubject.CLUB_CONTENT:\n                    dispatch(setTotalDocs(contentsCount));\n                    **getPapers = getClubContents;**\n                    return renderContents(clubContents);\n\n\t\t\t\t\t\t\t\tcase ContentSubject.GROUP_CONTENT:\n                    dispatch(setTotalDocs(contentsCount));\n                    **getPapers = getGroupContents;**\n                    return renderContents(groupContents);\n\t\t\t\t\t\t\t\t\t\t// ...\n// ...\n\nreturn (\n            \u0026#x3C;\u003e\n                \u0026#x3C;div\u003e\n                    {loading \u0026#x26;\u0026#x26; \u0026#x3C;Loading /\u003e}\n                    {!loading \u0026#x26;\u0026#x26; renderPapers()}\n                \u0026#x3C;/div\u003e\n                \u0026#x3C;br /\u003e\n                {!loading \u0026#x26;\u0026#x26; \u0026#x3C;Pagination **getPapers={getPapers}** /\u003e}\n            \u0026#x3C;/\u003e\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprop으로 받은 getPapers 함수를 통해 switch문을 삭제했다.\u003c/p\u003e\n\u003cp\u003e한결 깔끔해진 것 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Pagination.tsx\n\nconst onPageClick = (pageNum: number) =\u003e {\n    dispatch(getPapers({ userID: userID, page: pageNum, perPage: perPage }))\n    setPage(pageNum)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e그런데 위에서 살펴봤듯이 view 로직과 data fetch 로직이 같이 있는 것이 비효율적이라는 생각을 했다.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e그래서 data fetch 로직을 수행하는 custom hook을 만들어서 컴포넌트들이 view 로직만 처리하도록 만들어보자.\u003c/p\u003e\n\u003ch3\u003eCustom Hook으로 의존성 분리하기\u003c/h3\u003e\n\u003cp\u003e그렇다면 view단 컴포넌트들이 사용하는 상태 관련 로직들이 뭐가 있는지 찾아보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e로딩 상태 (현재 fetch 중이어서 로딩 상태인지)\u003c/li\u003e\n\u003cli\u003e선택한 글에 따라 해당 글 상세 정보 가져오기 (댓글, 해당 글 내용, 글 작성자 등)\u003c/li\u003e\n\u003cli\u003e현재 어느 게시판인지에 따라 data fetch\u003c/li\u003e\n\u003cli\u003epagination 용 정보 (현재 page, total pages)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e글이 길어져, 4에 해당하는 로직을 custom hook으로 추출해서 어떻게 의존성을 분리했는지만 살펴보자.\u003c/p\u003e\n\u003cp\u003e리팩토링 이전에는 위에서 살펴봤듯이 Pagination 컴포넌트에는 pagination view를 렌더링하는 로직과 더불어 페이지 클릭 시 (혹은 next, before 버튼 클릭 시) 해당 페이지에 맞는 게시글들을 불러오는 상태 로직이 같이 존재했었다.\u003c/p\u003e\n\u003cp\u003e따라서 view 로직만 남겨두어 가독성을 올려보자.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003epagination view를 위한 상태 (전체 페이지 수, 현재 페이지, 한 페이지 당 몇 row 등) 를 usePagination라는 커스텀 훅에서 다룬다.\u003c/li\u003e\n\u003cli\u003e게시글 fetch관련 상태 로직을 useFetchPage 라는 커스텀 훅에서 다룬다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이렇게 하면 Pagination 컴포넌트에서 상태 로직을 다루지 않고 위 두 custom hook을 구독함으로써 페이지네이션 기능을 구현할 수 있다.\u003c/p\u003e\n\u003cp\u003e간략한 코드를 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// usePagination.ts\nexport const usePagination = () =\u003e {\n    **const { getPapers } = useFetchPage();**\n\n    const [page, setPage] = useState(1);\n    const [perPage, setPerPage] = useState(10);\n    const totalPages = Math.ceil(totalDocs / perPage);\n    const [pageList, setPageList] = useState(Array(0));\n\n    useEffect(() =\u003e {\n\n        settingPageList(totalPages);\n\n    }, [page])\n\n    const onPageClick = async (pageNum: number) =\u003e {\n        setPage(pageNum);\n        **getPapers(pageNum);**\n    }\n\n    const onBefore = () =\u003e { }\n\n    const onNext = () =\u003e { }\n\n    return { page, perPage, pageList, onPageClick }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euseFetchPage 커스텀 훅으로부터 페이지 클릭 시 해당 페이지의 게시글을 렌더링하는 함수를 받아서 사용한다.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 상태 관련 로직을 모두 커스텀 훅에서 처리할 수 있다.\u003c/p\u003e\n\u003cp\u003e아래는 \u003cs\u003e이제야 좀\u003c/s\u003e 단순해진 Pagination 컴포넌트의 모습이다.\u003c/p\u003e\n\u003cp\u003erenderPageList로 view 로직만 처리하고 있어 가독성이 훨씬 좋아졌다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst Pagination = () =\u003e {\n\n    const loading = useBoardLoading();\n    **const { page, pageList, onPageClick } = usePagination();**\n\n    const renderPageList = () =\u003e {\n        return pageList.map(pageNum =\u003e {\n\n            if (pageNum === page) {\n                return (\n                    \u0026#x3C;Button color='primary' variant=\"outlined\" onClick={() =\u003e onPageClick(pageNum)}\u003e\n                        {pageNum}\n                    \u0026#x3C;/Button \u003e\n                )\n            } else {\n                return (\n                    \u0026#x3C;Button onClick={() =\u003e onPageClick(pageNum)}\u003e\n                        {pageNum}\n                    \u0026#x3C;/Button \u003e\n                )\n            }\n        })\n    }\n\n    return ( ... )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 withPaperContainer 라는 부모 컴포넌트를 리팩토링해서 재사용성을 높이고자 했는데, custom hook을 통해 해결하면서 부모 컴포넌트의 구조가 더 간결해졌다.\u003c/p\u003e\n\u003cp\u003ePagination 컴포넌트에게 컨텐츠를 불러오는 함수를 내려줄 필요가 없어졌기 때문에 부모 컴포넌트 또한 원래 존재목적대로 렌더링 로직만 남아있게 됐다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// withPaperContainer.tsx\n\nconst withPaperContainer = () =\u003e {\n\n\tconst PaperContainer = () =\u003e {\n\n\t\t\t\t\t.\n\t\t\t\t\t.\n\t\t\t\t\t.\n\n\t\tconst renderPapers = () =\u003e {\n\n            switch (contentSubject) {\n\n                case ContentSubject.CLUB_CONTENT:\n                    return renderContents(clubContents);\n\n                case ContentSubject.GROUP_CONTENT:\n                    return renderContents(groupContents);\n\n                case ContentSubject.MY_CONTENT:\n                    return renderContents(myContents);\n\n                case ContentSubject.MY_COMMENT:\n                    return renderMyComments(myComments);\n\n                default:\n                    break;\n            }\n    }\n\n\t\treturn ( ... )\n\t}\n\n\treturn PaperContainer;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e리팩토링 이후\u003c/h3\u003e\n\u003cimg src=\"/assets/blog/reusable-component/performance-before.png\" width=\"500\" height=\"300\"\u003e\n\u003cimg src=\"/assets/blog/reusable-component/performance-after.png\" width=\"500\" height=\"300\"\u003e\n\u003cp\u003e성능 개선을 목표로 리팩토링을 시작한 것은 아니었으나.. 성능 개선에 도움이 된 것 같다.\u003c/p\u003e\n\u003cp\u003e다음 글은 사이트 성능 개선을 위한 리팩토링을 해보고 써보자,,,\u003c/p\u003e","ogImage":{"url":"/assets/blog/reusable-component/preview.png"},"coverImage":"/assets/blog/reusable-component/preview.png"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"reusable-component"},"buildId":"1ougnSbgCeokHucbmlfpM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/fire.jpeg"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/fire.jpeg"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/fire.jpeg"/><link rel="manifest" href="/favicon/fire.jpeg"/><link rel="mask-icon" href="/favicon/fire.jpeg" color="#000000"/><link rel="shortcut icon" href="/favicon/fire.jpeg"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/favicon/fire.jpeg"/><meta name="description" content="codeKiuk"/><title>가볍게 사이트 성능 측정 및 개선 | Error</title><meta property="og:image" content="/assets/blog/ginger-performance-test/opportunity.png"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/02cef8d60abc4ccd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/02cef8d60abc4ccd.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e1f6961df2961232.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1f6961df2961232.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-38102973b285480e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20835bb07712f6c7.js" defer=""></script><script src="/_next/static/chunks/202-c144248cd2d53e87.js" defer=""></script><script src="/_next/static/chunks/72-32489d1a2b163d71.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-336c2ced50a7659a.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_buildManifest.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_ssgManifest.js" defer=""></script><script src="/_next/static/1ougnSbgCeokHucbmlfpM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-xl md:text-2xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" style="color:black" href="/">Kiuk</a>.</h2><article class="mb-32"><h1 class="text-3xl md:text-4xl lg:text-5xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">가볍게 사이트 성능 측정 및 개선</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><img src="/assets/blog/authors/FIRE.jpeg" class="w-12 h-12 rounded-full mr-4"/><div class="text-xl font-bold"><a style="color:black">codeKiuk</a></div></div></div><div class="mb-8 md:mb-16 sm:mx-0"><div class="sm:mx-0"><img src="/assets/blog/ginger-performance-test/preview.png" alt="Cover Image for 가볍게 사이트 성능 측정 및 개선" class="shadow-sm"/></div></div><div class="max-w-2xl mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><img src="/assets/blog/authors/FIRE.jpeg" class="w-12 h-12 rounded-full mr-4"/><div class="text-xl font-bold"><a style="color:black">codeKiuk</a></div></div></div><div class="mb-6 text-lg"><time dateTime="2021-09-01">September	1, 2021</time></div></div><div class="max-w-3xl mx-auto"><div class="markdown-styles_markdown__h_8de"><h3>들어가며</h3>
<p><img src="/assets/blog/ginger-performance-test/mobile-test-before.png" alt="모바일 테스트"></p>
<p>모바일 테스트</p>
<p><img src="/assets/blog/ginger-performance-test/desktop-test-before.png" alt="데스크탑 테스트"></p>
<p>데스크탑 테스트</p>
<p>Custom Hook을 통해 의존성 분리를 통해 가독성을 높인 후 구글 lighthouse를 통해 사이트 성능을 측정해보았다.</p>
<p>모바일의 경우 데스크탑보다 성능이 떨어지기 때문에 퍼포먼스 테스트에서 낮은 점수를 보여주는 것 같다.</p>
<p>처음 테스트 후 여러 번 프로파일링을 해봤는데 50점대를 기어다녀서 이 기회에 성능 개선을 하기로 했다.</p>
<p>lighthouse에서는 아래와 같이 친절히 진단해준다.</p>
<p><img src="/assets/blog/ginger-performance-test/opportunity.png" alt="스크린샷 2021-09-07 오후 2.18.48.png"></p>
<blockquote>
<p><strong>Opportunity</strong></p>
</blockquote>
<p>HTTP/2를 사용하라는 것을 제외하면 (도메인이 없어 https가 아니라 HTTP/1.1로만 요청한다,,ㅎ,) JS 크기를 줄이고 텍스트를 압축해서 req/res하라는 등 리소스를 줄이는 것이 좋다고 하는 것 같다.</p>
<p>최상위 App.tsx에서 Route별로 lazy loading을 통해 코드 스플리팅을 했는데도 50점대라.. 추가적으로 스플리팅할 수 있는 부분을 찾아보도록 하자.</p>
<p>먼저 코드 스플리팅은 일반적으로 다음과 같은 경우에 적용할 수 있다.</p>
<ol>
<li>Route 레벨</li>
<li>Component 레벨 (모달, form 등)</li>
<li>하나의 페이지가 너무 많은 컴포넌트를 가지고 있을 경우 해당 페이지를 스플리팅</li>
</ol>
<p>컴포넌트 레벨에서 스플리팅을 해보자.</p>
<p>코드 스플리팅 적용 후 빌드를 하니 스플리팅 이전보다 빌드 결과로 나온 js 파일의 수가 많아졌다!</p>
<p><img src="/assets/blog/ginger-performance-test/code-splitting.png" alt="스크린샷 2021-09-07 오후 5.14.14.png"></p>
<blockquote>
<p><strong>결과</strong></p>
</blockquote>
<p>모바일 환경에서 83점을 기록한 것으로 코드스플리팅의 효과가 없지는 않은 걸로...</p>
<p>But.. 앱 자체 크기도 크지 않고 텍스트 데이터만 crud 하는 게 전부인지라 성능 개선이 크게 의미있지는 않았던 것 같다. 애초에 단순 기능만 들어있으니,,</p>
<p>또한 실제로 속도면에서 사람이 체감할 정도로 좋아진 건 아니라 점수가 많이 올라도 정말 좋아진 건가? 하는 의문이 들긴 한다..</p>
<p>그래도 실제로 코드 스플리팅을 해보고 빌드 결과가 달라지는 것도 보고.. 경험하는 것은 언제나 좋으니 좋게 좋게 생각해보도록 하자 ^0^</p>
<p>추가적으로 이 플젝에서 해볼 수 있는 최적화 작업은</p>
<ol>
<li><strong>도메인적용해서 https로 바꾸기 ^.^....</strong></li>
<li>s3 등 정적 리소스용 DB를 파서 js 파일 실행없이 마크업을 바로 보여주도록 한다 (FCP)</li>
<li>웹폰트 최적화</li>
</ol>
<p>정도가 있을 것 같다.</p>
<p><img src="/assets/blog/ginger-performance-test/mobile-test-after.png" alt="스크린샷 2021-09-07 오후 9.25.22.png"></p>
<blockquote>
<p><strong>Error Handling</strong></p>
</blockquote>
<p>Cannot update { Pagination } while rendering { withPaperContainer } 오류가 나서 찾아보니 hoc인 withPaperContainer를 렌더하는 중에 Pagination 컴포넌트가 업데이트되지 않아 발생한 것이었다.</p>
<p>확인해보니 pagination 로직이 hoc 안에도 있고 Pagination 컴포넌트 안에도 있어서 다음 페이지를 눌렀는데도 다음 숫자로 렌더되지 않고 리스트만 다음 페이지 리스트로 업데이트되는 에러가 났었다. (hoc 렌더 중 side effect 발생)</p>
<p>이를 해결하기 위해,</p>
<ol>
<li>withPaperContainer HOC에서 Pagination 컴포넌트 렌더링 기능을 제거하고 Main과 MyContent에서 Pagination 컴포넌트가 각자 렌더링을 담당하도록 만들고 (+ custom hook으로 pagination 로직 공유)</li>
<li>Pagination 컴포넌트에서 페이지네이션 로직 제거 → usePagination, useFetchPage 훅에 옮기</li>
<li>기존에는 HOC에서 render할 때마다 setTotalDocs했는데 useEffect로 contentCount 바뀌었을 때만 setTotalDocs 액션을 dispatch 했다.</li>
</ol>
<p>결국 hoc에서 페이징 로직을 빼고 페이징에 따라 글을 렌더하는 기능 하나만 남길 수 있었다!</p></div></div></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"가볍게 사이트 성능 측정 및 개선","date":"2021-09-01","slug":"ginger-performance-test","content":"\u003ch3\u003e들어가며\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/ginger-performance-test/mobile-test-before.png\" alt=\"모바일 테스트\"\u003e\u003c/p\u003e\n\u003cp\u003e모바일 테스트\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/ginger-performance-test/desktop-test-before.png\" alt=\"데스크탑 테스트\"\u003e\u003c/p\u003e\n\u003cp\u003e데스크탑 테스트\u003c/p\u003e\n\u003cp\u003eCustom Hook을 통해 의존성 분리를 통해 가독성을 높인 후 구글 lighthouse를 통해 사이트 성능을 측정해보았다.\u003c/p\u003e\n\u003cp\u003e모바일의 경우 데스크탑보다 성능이 떨어지기 때문에 퍼포먼스 테스트에서 낮은 점수를 보여주는 것 같다.\u003c/p\u003e\n\u003cp\u003e처음 테스트 후 여러 번 프로파일링을 해봤는데 50점대를 기어다녀서 이 기회에 성능 개선을 하기로 했다.\u003c/p\u003e\n\u003cp\u003elighthouse에서는 아래와 같이 친절히 진단해준다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/ginger-performance-test/opportunity.png\" alt=\"스크린샷 2021-09-07 오후 2.18.48.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eOpportunity\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHTTP/2를 사용하라는 것을 제외하면 (도메인이 없어 https가 아니라 HTTP/1.1로만 요청한다,,ㅎ,) JS 크기를 줄이고 텍스트를 압축해서 req/res하라는 등 리소스를 줄이는 것이 좋다고 하는 것 같다.\u003c/p\u003e\n\u003cp\u003e최상위 App.tsx에서 Route별로 lazy loading을 통해 코드 스플리팅을 했는데도 50점대라.. 추가적으로 스플리팅할 수 있는 부분을 찾아보도록 하자.\u003c/p\u003e\n\u003cp\u003e먼저 코드 스플리팅은 일반적으로 다음과 같은 경우에 적용할 수 있다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRoute 레벨\u003c/li\u003e\n\u003cli\u003eComponent 레벨 (모달, form 등)\u003c/li\u003e\n\u003cli\u003e하나의 페이지가 너무 많은 컴포넌트를 가지고 있을 경우 해당 페이지를 스플리팅\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e컴포넌트 레벨에서 스플리팅을 해보자.\u003c/p\u003e\n\u003cp\u003e코드 스플리팅 적용 후 빌드를 하니 스플리팅 이전보다 빌드 결과로 나온 js 파일의 수가 많아졌다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/ginger-performance-test/code-splitting.png\" alt=\"스크린샷 2021-09-07 오후 5.14.14.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e결과\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e모바일 환경에서 83점을 기록한 것으로 코드스플리팅의 효과가 없지는 않은 걸로...\u003c/p\u003e\n\u003cp\u003eBut.. 앱 자체 크기도 크지 않고 텍스트 데이터만 crud 하는 게 전부인지라 성능 개선이 크게 의미있지는 않았던 것 같다. 애초에 단순 기능만 들어있으니,,\u003c/p\u003e\n\u003cp\u003e또한 실제로 속도면에서 사람이 체감할 정도로 좋아진 건 아니라 점수가 많이 올라도 정말 좋아진 건가? 하는 의문이 들긴 한다..\u003c/p\u003e\n\u003cp\u003e그래도 실제로 코드 스플리팅을 해보고 빌드 결과가 달라지는 것도 보고.. 경험하는 것은 언제나 좋으니 좋게 좋게 생각해보도록 하자 ^0^\u003c/p\u003e\n\u003cp\u003e추가적으로 이 플젝에서 해볼 수 있는 최적화 작업은\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e도메인적용해서 https로 바꾸기 ^.^....\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003es3 등 정적 리소스용 DB를 파서 js 파일 실행없이 마크업을 바로 보여주도록 한다 (FCP)\u003c/li\u003e\n\u003cli\u003e웹폰트 최적화\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e정도가 있을 것 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/ginger-performance-test/mobile-test-after.png\" alt=\"스크린샷 2021-09-07 오후 9.25.22.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eError Handling\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCannot update { Pagination } while rendering { withPaperContainer } 오류가 나서 찾아보니 hoc인 withPaperContainer를 렌더하는 중에 Pagination 컴포넌트가 업데이트되지 않아 발생한 것이었다.\u003c/p\u003e\n\u003cp\u003e확인해보니 pagination 로직이 hoc 안에도 있고 Pagination 컴포넌트 안에도 있어서 다음 페이지를 눌렀는데도 다음 숫자로 렌더되지 않고 리스트만 다음 페이지 리스트로 업데이트되는 에러가 났었다. (hoc 렌더 중 side effect 발생)\u003c/p\u003e\n\u003cp\u003e이를 해결하기 위해,\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewithPaperContainer HOC에서 Pagination 컴포넌트 렌더링 기능을 제거하고 Main과 MyContent에서 Pagination 컴포넌트가 각자 렌더링을 담당하도록 만들고 (+ custom hook으로 pagination 로직 공유)\u003c/li\u003e\n\u003cli\u003ePagination 컴포넌트에서 페이지네이션 로직 제거 → usePagination, useFetchPage 훅에 옮기\u003c/li\u003e\n\u003cli\u003e기존에는 HOC에서 render할 때마다 setTotalDocs했는데 useEffect로 contentCount 바뀌었을 때만 setTotalDocs 액션을 dispatch 했다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e결국 hoc에서 페이징 로직을 빼고 페이징에 따라 글을 렌더하는 기능 하나만 남길 수 있었다!\u003c/p\u003e","ogImage":{"url":"/assets/blog/ginger-performance-test/opportunity.png"},"coverImage":"/assets/blog/ginger-performance-test/preview.png"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"ginger-performance-test"},"buildId":"1ougnSbgCeokHucbmlfpM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
{"pageProps":{"post":{"title":"재사용 가능한 컴포넌트 만들기","date":"2021-09-01","slug":"reusable-component","content":"<h3>들어가며</h3>\n<p>풀스택 CRUD 게시판을 하나 만들어보자 라는 생각으로 21.08.15에 시작한 동아리 | 소모임 게시판 서비스 Ginger의 <a href=\"https://github.com/codeKiuk/Ginger\">코드</a> 를 천천히 뜯어보며 리팩토링 하기로 마음먹었다.</p>\n<p>내가 쓴 코드가 일단 돌아만 가는 <s>개노답</s> 코드라는 걸 알고는 있었지만 뭘 어떻게 만들어야 확장성이 좋은 코드인지, 어떻게 짜는 것이 클-린한지 몰랐다.</p>\n<p>그러다가 <a href=\"https://jbee.io/etc/what-is-good-code/\">이 글</a> 을 보고 조금의 힌트를 얻어, 선배님이 생각하시는 좋은 코드의 기준인</p>\n<ul>\n<li>\n<p>의존성이 잘 드러나도록 추상화되어 있는가</p>\n</li>\n<li>\n<p>확장성 있는 컴포넌트인가</p>\n</li>\n</ul>\n<p>에 맞춰 리팩토링을 진행하기로 했다.</p>\n<h3>프로젝트 구조 파악</h3>\n<p>의존성을 잘 드러내는 추상화 (한 파일이 하나의 목적을 갖도록 로직 분리) 를 이루기 위해서는</p>\n<p>우선 프로젝트의 구조를 파악해 어떤 로직들이 존재하고,</p>\n<p>이 로직들이 어느 파일에 어떻게 존재하는지 파악하는 것이 먼저다.</p>\n<img src=\"/assets/blog/reusable-component/directory0.png\" width=\"200\" height=\"500\">\n<p>redux 구조</p>\n<img src=\"/assets/blog/reusable-component/directory1.png\" width=\"200\" height=\"500\">\n<p>컴포넌트들</p>\n<img src=\"/assets/blog/reusable-component/directory2.png\" width=\"200\" height=\"500\">\n<img src=\"/assets/blog/reusable-component/directory3.png\" width=\"200\" height=\"500\">\n<p>Route &#x26; Higher Order Components</p>\n<p>Ginger 클라이언트 디렉토리는 어떤 기능을 하는지 (component인지, route page인지, redux인지) 에 따라 폴더 구조를 나눴다.</p>\n<ol>\n<li>이 구조가 가질 수 있는 문제점은 플젝 규모가 커지면 코드가 정의된 곳과 이를 사용하는 곳이 멀어질 수 있다는 점.. <s>사실 이미 좀 멀어져 있다...</s></li>\n<li>또한 MVC라든지 MVVM라든지 디자인 패턴에 대한 지식 없이 구성해서 좋은 의존성에 대한 고민을 많이 못 했다. ⇒ ( components/commons/Pagination.tsx 이라는 컴포넌트 안에 pagination view 로직이 들어있는 동시에 컨텐츠를 가져오는 상태 관련 로직이 동시에 존재하는 등 의존성 분리를 하지 못 했다. )</li>\n</ol>\n<h3>문제 찾아보기</h3>\n<p>먼저 프로젝트 코드 전반적으로 redux와 thunk를 통해 전역 상태와 data fetch를 다루면서 재사용 가능한 컴포넌트를 많이 만들지 못 했다. (redux 덕분에 자식 컴포넌트에 props를 내려주는 일을 거의 안 하면서..)</p>\n<p>그럼에도 불구하고 확장성을 생각한 포인트로는</p>\n<p>→ withPaperContainer라는 고차컴포넌트를 통해 동아리 게시판 전체 글을 불러오거나 내가 쓴 글, 댓글을 불러오는 등 컨텐츠를 fetch하는 <strong>중복되는 로직</strong>을 한 곳에서 처리했다.</p>\n<p>그렇다면 이 외에 재사용 가능하도록 만들어볼 <s>구린</s> 컴포넌트 혹은 view로직과 상태 로직이 같이 있는 복잡한 컴포넌트를 찾아보자.</p>\n<blockquote>\n<p>Sidebar</p>\n</blockquote>\n<p>Sidebar에서 메뉴를 클릭하면 클릭한 메뉴가 어떤 메뉴인지 전역 store에 ContentSubject라는 enum 타입을 통해 저장한다. 이후 해당하는 컨텐츠(글or댓글 등)를 불러오는 함수를 dispatch한다.</p>\n<p>그런데 Sidebar에서 메뉴 클릭 후 라우트를 mypage 혹은 home으로 옮겨오는데, 이 때 각 라우트를 구성하는 컴포넌트의 useEffect에서도 Sidebar에서와 마찬가지로 컨텐츠를 불러오는 함수를 dispatch한다.</p>\n<p>따라서 개발 당시 만들었던 중복 로직을 삭제해줬다.</p>\n<pre><code>// 수정된 Sidebar.tsx\n// 클릭한 메뉴에 따라 전역 store에 알려주는 함수에서 중복 로직 삭제\n\nconst onClickContentsMenu = (title: string) => {\n    switch (title) {\n        case '동아리 / 학회':\n            dispatch(setContentSubject(ContentSubject.CLUB_CONTENT))\n            // 중복로직 삭제 => dispatch(getClubContents({ page: 1, perPage: perPage }));\n            break\n        case '스터디 / 소모임':\n            dispatch(setContentSubject(ContentSubject.GROUP_CONTENT))\n            // 중복로직 삭제 => dispatch(getGroupContents({ page: 1, perPage: perPage }));\n            break\n        case '내가 쓴 글':\n            dispatch(setContentSubject(ContentSubject.MY_CONTENT))\n            // 중복로직 삭제 => dispatch(getMyContents({ userID: userID ,page: 1, perPage: perPage }));\n            break\n        case '내가 쓴 댓글':\n            dispatch(setContentSubject(ContentSubject.MY_COMMENT))\n            // 중복로직 삭제 => dispatch(getMyComments({ userID: userID ,page: 1, perPage: perPage }));\n            break\n        default:\n            break\n    }\n}\n</code></pre>\n<blockquote>\n<p>Pagination</p>\n</blockquote>\n<p>글을 쓰게 된 계기인 <s>개구린</s> 페이지네이션 컴포넌트.</p>\n<p>먼저 바뀌기 전 코드를 보자.</p>\n<pre><code>// Pagination.tsx\n\nexport const Pagination: React.FC&#x3C;{}> = () => {\n    const contentsLoading = useAppSelector((state) => state.contents.loading)\n    const myCommentsLoading = useAppSelector(\n        (state) => state.myComments.loading\n    )\n    const myContentsLoading = useAppSelector(\n        (state) => state.myContents.loading\n    )\n\n    const loading = contentsLoading || myCommentsLoading || myContentsLoading\n    const contentSubject = useAppSelector(\n        (state) => state.contentMenu.contentSubject\n    )\n\n    // ...\n\n    const onPageClick = (pageNum: number) => {\n        switch (contentSubject) {\n            case ContentSubject.CLUB_CONTENT:\n                dispatch(getClubContents({ page: pageNum, perPage: perPage }))\n                break\n            case ContentSubject.GROUP_CONTENT:\n                dispatch(getGroupContents({ page: pageNum, perPage: perPage }))\n                break\n            case ContentSubject.MY_CONTENT:\n                dispatch(\n                    getMyContents({\n                        userID: userID,\n                        page: pageNum,\n                        perPage: perPage,\n                    })\n                )\n                break\n            case ContentSubject.MY_COMMENT:\n                dispatch(\n                    getMyComments({\n                        userID: userID,\n                        page: pageNum,\n                        perPage: perPage,\n                    })\n                )\n                break\n            default:\n                break\n        }\n\n        setPage(pageNum)\n    }\n\n    // ...\n}\n</code></pre>\n<p>대충 봐도 재사용하기 어려운 컴포넌트라는 것을 알 수 있다.</p>\n<p>-문제-</p>\n<ol>\n<li>\n<p>사이드바 메뉴 (즉 게시판 종류) 가 늘어났을 때 switch문 안에 case를 추가할 수 있겠으나 가독성이 떨어진다.</p>\n</li>\n<li>\n<p>또한 Pagination만 하는 컴포넌트인데 컨텐츠를 가져오는 로직이 섞여있어서 유지보수하기 어려워보인다.</p>\n<p>이는 Sidebar에서도 있었던 문제로, 컨텐츠를 가져오는 로직이 여러 군데 퍼져있다.</p>\n</li>\n<li>\n<p>loading 또한 게시판 메뉴가 확장될 때마다 하드코딩해야한다.</p>\n</li>\n</ol>\n<p>따라서 Pagination 컴포넌트의 부모 컴포넌트 역할을 하는 withPaperContainer의 코드를 수정함으로 위 문제를 해결했다.</p>\n<ol>\n<li>Page를 옮겼을 때 새로 컨텐츠를 가져와야 하는 것은 꼭 필요한 로직이기 때문에 Pagination의 부모 컴포넌트에서 prop으로 getPapers 함수를 넘겨준다. (뒤에서 컨텐츠를 가져오는 상태 로직을 커스텀 훅으로 분리할 예정이다.)</li>\n<li>로딩 또한 페이지네이션 컴포넌트가 아닌 부모 컴포넌트에서 처리해준다.</li>\n</ol>\n<pre><code>// withPaperContainer.tsx\n\n**let getPapers = Function();**\n\n// ...\n\nconst renderPapers = () => {\n\n            switch (contentSubject) {\n\n                case ContentSubject.CLUB_CONTENT:\n                    dispatch(setTotalDocs(contentsCount));\n                    **getPapers = getClubContents;**\n                    return renderContents(clubContents);\n\n\t\t\t\t\t\t\t\tcase ContentSubject.GROUP_CONTENT:\n                    dispatch(setTotalDocs(contentsCount));\n                    **getPapers = getGroupContents;**\n                    return renderContents(groupContents);\n\t\t\t\t\t\t\t\t\t\t// ...\n// ...\n\nreturn (\n            &#x3C;>\n                &#x3C;div>\n                    {loading &#x26;&#x26; &#x3C;Loading />}\n                    {!loading &#x26;&#x26; renderPapers()}\n                &#x3C;/div>\n                &#x3C;br />\n                {!loading &#x26;&#x26; &#x3C;Pagination **getPapers={getPapers}** />}\n            &#x3C;/>\n        )\n</code></pre>\n<p>prop으로 받은 getPapers 함수를 통해 switch문을 삭제했다.</p>\n<p>한결 깔끔해진 것 같다.</p>\n<pre><code>// Pagination.tsx\n\nconst onPageClick = (pageNum: number) => {\n    dispatch(getPapers({ userID: userID, page: pageNum, perPage: perPage }))\n    setPage(pageNum)\n}\n</code></pre>\n<p><strong>그런데 위에서 살펴봤듯이 view 로직과 data fetch 로직이 같이 있는 것이 비효율적이라는 생각을 했다.</strong></p>\n<p>그래서 data fetch 로직을 수행하는 custom hook을 만들어서 컴포넌트들이 view 로직만 처리하도록 만들어보자.</p>\n<h3>Custom Hook으로 의존성 분리하기</h3>\n<p>그렇다면 view단 컴포넌트들이 사용하는 상태 관련 로직들이 뭐가 있는지 찾아보자.</p>\n<ol>\n<li>로딩 상태 (현재 fetch 중이어서 로딩 상태인지)</li>\n<li>선택한 글에 따라 해당 글 상세 정보 가져오기 (댓글, 해당 글 내용, 글 작성자 등)</li>\n<li>현재 어느 게시판인지에 따라 data fetch</li>\n<li>pagination 용 정보 (현재 page, total pages)</li>\n</ol>\n<p>글이 길어져, 4에 해당하는 로직을 custom hook으로 추출해서 어떻게 의존성을 분리했는지만 살펴보자.</p>\n<p>리팩토링 이전에는 위에서 살펴봤듯이 Pagination 컴포넌트에는 pagination view를 렌더링하는 로직과 더불어 페이지 클릭 시 (혹은 next, before 버튼 클릭 시) 해당 페이지에 맞는 게시글들을 불러오는 상태 로직이 같이 존재했었다.</p>\n<p>따라서 view 로직만 남겨두어 가독성을 올려보자.</p>\n<ol>\n<li>pagination view를 위한 상태 (전체 페이지 수, 현재 페이지, 한 페이지 당 몇 row 등) 를 usePagination라는 커스텀 훅에서 다룬다.</li>\n<li>게시글 fetch관련 상태 로직을 useFetchPage 라는 커스텀 훅에서 다룬다.</li>\n</ol>\n<p>이렇게 하면 Pagination 컴포넌트에서 상태 로직을 다루지 않고 위 두 custom hook을 구독함으로써 페이지네이션 기능을 구현할 수 있다.</p>\n<p>간략한 코드를 보자.</p>\n<pre><code>// usePagination.ts\nexport const usePagination = () => {\n    **const { getPapers } = useFetchPage();**\n\n    const [page, setPage] = useState(1);\n    const [perPage, setPerPage] = useState(10);\n    const totalPages = Math.ceil(totalDocs / perPage);\n    const [pageList, setPageList] = useState(Array(0));\n\n    useEffect(() => {\n\n        settingPageList(totalPages);\n\n    }, [page])\n\n    const onPageClick = async (pageNum: number) => {\n        setPage(pageNum);\n        **getPapers(pageNum);**\n    }\n\n    const onBefore = () => { }\n\n    const onNext = () => { }\n\n    return { page, perPage, pageList, onPageClick }\n}\n</code></pre>\n<p>useFetchPage 커스텀 훅으로부터 페이지 클릭 시 해당 페이지의 게시글을 렌더링하는 함수를 받아서 사용한다.</p>\n<p>이렇게 하면 상태 관련 로직을 모두 커스텀 훅에서 처리할 수 있다.</p>\n<p>아래는 <s>이제야 좀</s> 단순해진 Pagination 컴포넌트의 모습이다.</p>\n<p>renderPageList로 view 로직만 처리하고 있어 가독성이 훨씬 좋아졌다.</p>\n<pre><code>const Pagination = () => {\n\n    const loading = useBoardLoading();\n    **const { page, pageList, onPageClick } = usePagination();**\n\n    const renderPageList = () => {\n        return pageList.map(pageNum => {\n\n            if (pageNum === page) {\n                return (\n                    &#x3C;Button color='primary' variant=\"outlined\" onClick={() => onPageClick(pageNum)}>\n                        {pageNum}\n                    &#x3C;/Button >\n                )\n            } else {\n                return (\n                    &#x3C;Button onClick={() => onPageClick(pageNum)}>\n                        {pageNum}\n                    &#x3C;/Button >\n                )\n            }\n        })\n    }\n\n    return ( ... )\n}\n</code></pre>\n<p>위에서 withPaperContainer 라는 부모 컴포넌트를 리팩토링해서 재사용성을 높이고자 했는데, custom hook을 통해 해결하면서 부모 컴포넌트의 구조가 더 간결해졌다.</p>\n<p>Pagination 컴포넌트에게 컨텐츠를 불러오는 함수를 내려줄 필요가 없어졌기 때문에 부모 컴포넌트 또한 원래 존재목적대로 렌더링 로직만 남아있게 됐다.</p>\n<pre><code>// withPaperContainer.tsx\n\nconst withPaperContainer = () => {\n\n\tconst PaperContainer = () => {\n\n\t\t\t\t\t.\n\t\t\t\t\t.\n\t\t\t\t\t.\n\n\t\tconst renderPapers = () => {\n\n            switch (contentSubject) {\n\n                case ContentSubject.CLUB_CONTENT:\n                    return renderContents(clubContents);\n\n                case ContentSubject.GROUP_CONTENT:\n                    return renderContents(groupContents);\n\n                case ContentSubject.MY_CONTENT:\n                    return renderContents(myContents);\n\n                case ContentSubject.MY_COMMENT:\n                    return renderMyComments(myComments);\n\n                default:\n                    break;\n            }\n    }\n\n\t\treturn ( ... )\n\t}\n\n\treturn PaperContainer;\n}\n\n</code></pre>\n<h3>리팩토링 이후</h3>\n<img src=\"/assets/blog/reusable-component/performance-before.png\" width=\"500\" height=\"300\">\n<img src=\"/assets/blog/reusable-component/performance-after.png\" width=\"500\" height=\"300\">\n<p>성능 개선을 목표로 리팩토링을 시작한 것은 아니었으나.. 성능 개선에 도움이 된 것 같다.</p>\n<p>다음 글은 사이트 성능 개선을 위한 리팩토링을 해보고 써보자,,,</p>","ogImage":{"url":"/assets/blog/reusable-component/preview.png"},"coverImage":"/assets/blog/reusable-component/preview.png"}},"__N_SSG":true}